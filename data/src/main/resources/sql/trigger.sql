DROP SEQUENCE CLIENTS_ID_SEQ
//

DROP SEQUENCE COMMENTS_ID_SEQ
//

DROP SEQUENCE CONTACTS_ID_SEQ
//

DROP SEQUENCE CURRENCY_ID_SEQ
//

DROP SEQUENCE EMPLOYEES_ID_SEQ
//

DROP SEQUENCE FLIGHTS_ID_SEQ
//

DROP SEQUENCE FOOD_ID_SEQ
//

DROP SEQUENCE HOTELS_ID_SEQ
//

DROP SEQUENCE LOCATIONS_ID_SEQ
//

DROP SEQUENCE OFFICES_ID_SEQ
//

DROP SEQUENCE PEOPLES_ID_SEQ
//

DROP SEQUENCE PHOTO_ID_SEQ
//

DROP SEQUENCE PLACEMENT_ID_SEQ
//

DROP SEQUENCE PLACES_ID_SEQ
//

DROP SEQUENCE ROOMS_ID_SEQ
//

DROP SEQUENCE TRAVELS_ID_SEQ
//

DROP SEQUENCE TOURS_ID_SEQ
//

DROP SEQUENCE USERS_ID_SEQ
//

CREATE SEQUENCE CLIENTS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE 
TRIGGER CLIENTS_ID_TRG BEFORE
  INSERT ON CLIENTS FOR EACH ROW BEGIN
  SELECT CLIENTS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE COMMENTS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER COMMENTS_ID_TRG BEFORE
  INSERT ON COMMENTS FOR EACH ROW BEGIN
    SELECT COMMENTS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE CONTACTS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER CONTACTS_ID_TRG BEFORE
  INSERT ON CONTACTS FOR EACH ROW BEGIN
    SELECT CONTACTS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE CURRENCY_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE 
TRIGGER CURRENCY_ID_TRG BEFORE
  INSERT ON CURRENCY FOR EACH ROW BEGIN
    SELECT CURRENCY_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE EMPLOYEES_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER EMPLOYEES_ID_TRG BEFORE
  INSERT OR UPDATE ON EMPLOYEES FOR EACH ROW BEGIN
    SELECT EMPLOYEES_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE FLIGHTS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER FLIGHTS_ID_TRG BEFORE
  INSERT ON FLIGHTS FOR EACH ROW BEGIN
    SELECT FLIGHTS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE FOOD_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE 
TRIGGER FOOD_ID_TRG BEFORE
  INSERT ON FOOD FOR EACH ROW BEGIN
    SELECT FOOD_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE HOTELS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER HOTELS_ID_TRG BEFORE
  INSERT ON HOTELS FOR EACH ROW BEGIN
    SELECT HOTELS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE LOCATIONS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER LOCATIONS_ID_TRG BEFORE
  INSERT ON LOCATIONS FOR EACH ROW BEGIN
    SELECT LOCATIONS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE OFFICES_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER OFFICES_ID_TRG BEFORE
  INSERT ON OFFICES FOR EACH ROW BEGIN
    SELECT OFFICES_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE PEOPLES_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER PEOPLES_ID_TRG BEFORE
  INSERT ON PEOPLES FOR EACH ROW BEGIN
    SELECT PEOPLES_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE PHOTO_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER PHOTO_ID_TRG BEFORE
  INSERT ON PHOTO FOR EACH ROW BEGIN
    SELECT PHOTO_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE PLACEMENT_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER PLACEMENT_ID_TRG BEFORE
  INSERT ON PLACEMENT FOR EACH ROW BEGIN
    SELECT PLACEMENT_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE PLACES_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER PLACES_ID_TRG BEFORE
  INSERT ON PLACES FOR EACH ROW
DECLARE
  ERR_PLACE EXCEPTION;
  IDENT INTEGER;
BEGIN
  SELECT PLACES_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
  SELECT COUNT(*) INTO IDENT FROM PLACES WHERE :NEW.ID = ID_PLACE AND :NEW.ID_PLACE = ID;
  IF IDENT > 0 THEN 
    RAISE ERR_PLACE;
  END IF;
EXCEPTION
  WHEN ERR_PLACE THEN RAISE_APPLICATION_ERROR(-20001, 'Неверно заданы идентификаторы, нарушается целостность данных');
END;
//

CREATE SEQUENCE ROOMS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER ROOMS_ID_TRG BEFORE
  INSERT ON ROOMS FOR EACH ROW BEGIN
    SELECT ROOMS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE TRAVELS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER TRAVELS_ID_TRG BEFORE
  INSERT ON TRAVELS FOR EACH ROW BEGIN
  SELECT TRAVELS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE TOURS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE 
TRIGGER TOURS_ID_TRG BEFORE 
  INSERT ON TOURS FOR EACH ROW BEGIN
  SELECT TOURS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

CREATE SEQUENCE USERS_ID_SEQ START WITH 1 NOCACHE ORDER
//

CREATE OR REPLACE
TRIGGER USERS_ID_TRG BEFORE 
	INSERT ON USERS FOR EACH ROW BEGIN
	SELECT USERS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
//

-- Триггеры, контролирующие целостность базы данных

CREATE OR REPLACE 
TRIGGER CLIENTS_TRIGGER BEFORE
  INSERT OR UPDATE ON CLIENTS FOR EACH ROW
  DECLARE
    EXIST_EMPLOYEE EXCEPTION;
    IDENT INTEGER;
  BEGIN
  -- проверка на существование человека с таким же ID_PEOPLE
  SELECT COUNT(*) INTO IDENT FROM EMPLOYEES WHERE :NEW.ID_PEOPLE = ID_PEOPLE;
  IF IDENT <> 0
    THEN RAISE EXIST_EMPLOYEE;
  END IF;
  EXCEPTION
    WHEN EXIST_EMPLOYEE THEN RAISE_APPLICATION_ERROR(-20000, 'Сотрудник с таким ID_PEOPLE уже существует');
END;
//

CREATE OR REPLACE
TRIGGER COMMENTS_TRIGGER BEFORE
  INSERT OR UPDATE ON COMMENTS FOR EACH ROW
  DECLARE
    NOT_EXIST_TARGET EXCEPTION;
    TOO_MANY_TARGETS EXCEPTION;
  BEGIN
    -- указан ли объект, кому предназначается комментарий
    IF :NEW.ID_HOTEL IS NULL
      AND :NEW.ID_PLACE IS NULL
      AND :NEW.ID_OFFICE IS NULL
      THEN RAISE NOT_EXIST_TARGET;
    END IF;

    -- указан ли только один объект
    IF :NEW.ID_HOTEL IS NOT NULL AND :NEW.ID_PLACE IS NOT NULL
      OR :NEW.ID_PLACE IS NOT NULL AND :NEW.ID_OFFICE IS NOT NULL
      OR :NEW.ID_HOTEL IS NOT NULL AND :NEW.ID_OFFICE IS NOT NULL
      THEN RAISE TOO_MANY_TARGETS;
    END IF;
  EXCEPTION
    WHEN NOT_EXIST_TARGET THEN RAISE_APPLICATION_ERROR(-20000, 'Не указан ID объекта, кому предназначается комментарий');
    WHEN TOO_MANY_TARGETS THEN RAISE_APPLICATION_ERROR(-20000, 'Можно присвоить комментарий только одному из объектов');
END;
//

CREATE OR REPLACE 
TRIGGER CURRENCY_TRIGGER BEFORE
  INSERT OR UPDATE ON CURRENCY FOR EACH ROW
  DECLARE
    NULL_VAL EXCEPTION;
    DESC_EXIST EXCEPTION;
    VAL INTEGER;
  BEGIN
    :NEW.DESCRIPTION := UPPER(:NEW.DESCRIPTION);
    -- проверка на существование кода валюты
    SELECT COUNT(*) INTO VAL FROM CURRENCY WHERE DESCRIPTION = :NEW.DESCRIPTION;
    IF VAL > 0
      THEN RAISE DESC_EXIST;
    END IF;
  EXCEPTION
    WHEN DESC_EXIST THEN RAISE_APPLICATION_ERROR(-20002, 'Указанный код валюты уже существует');
END;
//

CREATE OR REPLACE
TRIGGER EMPLOYEES_TRIGGER BEFORE
  INSERT OR UPDATE ON EMPLOYEES FOR EACH ROW
  DECLARE
    EXIST_CLIENT EXCEPTION;
    IDENT INTEGER;
  BEGIN
    -- проверка на существование человека с таким ID_PEOPLE
    SELECT COUNT(*) INTO IDENT FROM CLIENTS WHERE ID_PEOPLE = :NEW.ID_PEOPLE;
    IF IDENT <> 0
      THEN RAISE EXIST_CLIENT;
    END IF;
  EXCEPTION
    WHEN EXIST_CLIENT THEN RAISE_APPLICATION_ERROR(-20002, 'Клиент с таким ID_PEOPLE уже существует');
END;
//

CREATE OR REPLACE
TRIGGER PEOPLES_TRIGGER BEFORE
  INSERT OR UPDATE ON PEOPLES FOR EACH ROW 
   DECLARE
    ERR_DATE EXCEPTION;
  BEGIN
    IF :NEW.DATE_BIRTH > SYSDATE
      THEN RAISE ERR_DATE;
    END IF;
    
    :NEW.FIRST_NAME := INITCAP(:NEW.FIRST_NAME);
    :NEW.LAST_NAME := INITCAP(:NEW.LAST_NAME);
    IF :NEW.MIDDLE_NAME IS NOT NULL
    THEN
      :NEW.MIDDLE_NAME := INITCAP(:NEW.MIDDLE_NAME);
    END IF;
  EXCEPTION
    WHEN ERR_DATE THEN RAISE_APPLICATION_ERROR(-20002, 'Неверная дата рождения');
END;
//

CREATE OR REPLACE
TRIGGER PHOTO_TRIGGER BEFORE
  INSERT OR UPDATE ON PHOTO FOR EACH ROW
  DECLARE
    TOO_MANY_TARGETS EXCEPTION;
    NOT_EXIST_TARGETS EXCEPTION;
  BEGIN
    IF :NEW.ID_HOTEL IS NULL
      AND :NEW.ID_PLACE IS NULL
      AND :NEW.ID_PEOPLE IS NULL
      THEN RAISE NOT_EXIST_TARGETS;
    END IF;
    
    IF :NEW.ID_HOTEL IS NOT NULL AND :NEW.ID_PLACE IS NOT NULL
      OR :NEW.ID_HOTEL IS NOT NULL AND :NEW.ID_PEOPLE IS NOT NULL
      OR :NEW.ID_PLACE IS NOT NULL AND :NEW.ID_PEOPLE IS NOT NULL
      THEN RAISE TOO_MANY_TARGETS;
    END IF;
  EXCEPTION
    WHEN TOO_MANY_TARGETS THEN RAISE_APPLICATION_ERROR(-20005, 'Слишком много объектов');
    WHEN NOT_EXIST_TARGETS THEN RAISE_APPLICATION_ERROR(-20006, 'Не указаны объекты, которым принадлежит фото');
END;
//

CREATE OR REPLACE 
TRIGGER TOURS_TRIGGER BEFORE
  INSERT OR UPDATE ON TOURS FOR EACH ROW
  DECLARE
    ID_LOCATION_TO INTEGER;
    ID_LOCATION_FROM INTEGER;
    ERR_LOCATION EXCEPTION;
  BEGIN
    -- проверка, что место отбытия клиента не совпадает с местом назначения
    -- получение ID локации, куда едет клиент
    SELECT LOCATIONS.ID INTO ID_LOCATION_TO FROM PLACES
    JOIN LOCATIONS ON PLACES.ID_LOCATION = LOCATIONS.ID
    WHERE PLACES.ID = :NEW.ID_PLACE;
     -- получение ID локации, откуда он отправляется
    SELECT LOCATIONS.ID INTO ID_LOCATION_FROM FROM CONTACTS
    JOIN OFFICES ON :NEW.ID_OFFICE = OFFICES.ID AND OFFICES.ID_CONTACT = CONTACTS.ID
    JOIN LOCATIONS ON LOCATIONS.ID = CONTACTS.ID_LOCATION;
    IF ID_LOCATION_TO = ID_LOCATION_FROM
      THEN RAISE ERR_LOCATION;
    END IF;
  EXCEPTION
    WHEN ERR_LOCATION THEN RAISE_APPLICATION_ERROR(-20000, 'ID локации офиса и места прибытия клиента совпадают');
END;
//

CREATE OR REPLACE TRIGGER PLACES_TRIGGER
after UPDATE ON PLACES FOR EACH ROW 
DECLARE
  ERR_PLACE EXCEPTION;
  IDENT INTEGER;
BEGIN
  --SELECT COUNT(*) INTO IDENT FROM PLACES WHERE :NEW.ID = ID_PLACE AND :NEW.ID_PLACE = ID;
 -- IF IDENT > 0 THEN 
    RAISE ERR_PLACE;
  --END IF;
EXCEPTION
  WHEN ERR_PLACE THEN RAISE_APPLICATION_ERROR(-20001, 'Неверно заданы идентификаторы, нарушается целостность данных');
END;
//

-- Функции

CREATE OR REPLACE
FUNCTION COUNT_ROOM_PRICE(ID_ROOM IN INTEGER, CURRENCY_DESC VARCHAR2)
RETURN FLOAT IS
  PRICE FLOAT := 0;
  RATE_RESULT FLOAT := 0;
BEGIN
  BEGIN
    SELECT CURRENCY.RATE INTO RATE_RESULT
    FROM CURRENCY
    WHERE DESCRIPTION = CURRENCY_DESC;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN RAISE_APPLICATION_ERROR(-20000, 'Неизвестный тип валюты');
  END;

  SELECT (FOOD.PRICE * CUR_FOOD.RATE + PLACEMENT.PRICE * CUR_PLACEMENT.RATE)
  INTO PRICE
  FROM ROOMS
  JOIN FOOD ON FOOD.ID = ROOMS.ID_FOOD
  JOIN PLACEMENT ON PLACEMENT.ID = ROOMS.ID_PLACEMENT
  JOIN CURRENCY CUR_FOOD ON CUR_FOOD.ID = FOOD.ID_CURRENCY
  JOIN CURRENCY CUR_PLACEMENT ON CUR_PLACEMENT.ID = PLACEMENT.ID_CURRENCY
  WHERE ROOMS.ID = ID_ROOM;
  IF PRICE IS NULL THEN 
    PRICE := 0; 
  END IF;
  RETURN PRICE / RATE_RESULT;
END COUNT_ROOM_PRICE;
//

CREATE OR REPLACE
FUNCTION COUNT_TOUR_PRICE(TOUR_ID IN INTEGER, CURRENCY_DESC VARCHAR2)
RETURN FLOAT IS
  RATE_RESULT FLOAT DEFAULT 0;
  PRICE FLOAT DEFAULT 0;
  PRICE_HOTEL FLOAT DEFAULT 0;
BEGIN
  BEGIN
    SELECT RATE INTO RATE_RESULT FROM CURRENCY
    WHERE DESCRIPTION = CURRENCY_DESC;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN RAISE_APPLICATION_ERROR(-20000, 'Неизвестный тип валюты');
  END;

  SELECT SUM(RP) INTO PRICE_HOTEL FROM (
    SELECT COUNT_ROOM_PRICE(ROOMS.ID, CURRENCY_DESC) RP
    FROM ROOMS
    JOIN HOTELS ON HOTELS.ID_TOUR = TOUR_ID
    WHERE ROOMS.ID_HOTEL = HOTELS.ID);
  SELECT SUM(FP) INTO PRICE FROM (
    SELECT (FLIGHTS.PRICE * CURRENCY.RATE) FP FROM FLIGHTS
    JOIN CURRENCY ON CURRENCY.ID = FLIGHTS.ID_CURRENCY
    WHERE FLIGHTS.ID_TOUR = TOUR_ID);
  IF PRICE_HOTEL IS NULL THEN 
    PRICE_HOTEL := 0; 
  END IF;
  IF PRICE IS NULL THEN 
    PRICE := 0; 
  END IF;
  PRICE := PRICE / RATE_RESULT + PRICE_HOTEL;
  RETURN (PRICE * 1.30);
END;
//